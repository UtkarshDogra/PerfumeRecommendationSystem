# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15NwJ7zL2ca83ybEP3j-TIXcDG5eSEWdu

# This NLP model gets matching words for all the words in a query and expands it, uses the modified query to search the description and the notes with the matching query words, and returns the perfumes that's closest to the expanded query
"""

# Libraries used
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import nltk
from nltk.corpus import wordnet
import numpy as np
import random
from itertools import chain

nltk.download('wordnet')

"""### Function for expanding the user input"""

# Synonym Expansion for User Input
def expand_query_with_synonyms(query):
    tokens = query.split()
    expanded_query = []

    for word in tokens:
        synonyms = wordnet.synsets(word)
        lemmas = set(chain.from_iterable([syn.lemma_names() for syn in synonyms]))

        # Add the original word and its synonyms to the query
        expanded_query.append(word)
        expanded_query.extend(lemmas)

    # Join the expanded query into a single string
    return " ".join(expanded_query)


"""### Loading the dataset"""

def loadDataset(path):
    # Step 1: Load and Preprocess the Fragrance Dataset
    data = pd.read_csv(path)#, encoding='ISO-8859-1')
    df = pd.DataFrame(data)

    df = df.dropna(subset=['Name', 'All Notes', 'Description', 'Brand', 'Image'])


    return df

"""### Adding weight to the notes and description"""

# Step 2: Feature Engineering - Create Weighted Combined Features
def create_weighted_features(df, weight_name = 4, weight_notes=2, weight_description=2, weight_gender=3,
                             weight_vibes=3, weight_ingredients=2, weight_concentration=1,
                             weight_year=3,weight_brand=3, weight_family=3):
    # Convert all relevant columns to strings and fill NaN with empty strings
    name = df['Name'].fillna('').astype(str)
    notes = df['All Notes'].fillna('').astype(str)
    descriptions = df['Description'].fillna('').astype(str)
    gender = df['Gender'].fillna('').astype(str)
    vibes = df['Vibes'].fillna('').astype(str)
    ingredients = df['Ingredients'].fillna('').astype(str)
    concentration = df['Concentration'].fillna('').astype(str)
    year = df['Year'].fillna('').astype(str)
    brand = df['Brand'].fillna('').astype(str)
    family = df['Fragrance_Family'].fillna('').astype(str)

    # Combine features with the specified weights
    combined = (name * weight_name + ' ' +
                notes * weight_notes + ' ' +
                descriptions * weight_description + ' ' +
                gender * weight_gender + ' ' +
                vibes * weight_vibes + ' ' +
                ingredients * weight_ingredients + ' ' +
                concentration * weight_concentration + ' ' +
                year * weight_year + ' ' +
                brand * weight_brand + ' ' +
                family * weight_family)

    combined = combined.str.strip()  # Remove leading/trailing spaces

    return combined


# Step 6: Get Diverse Recommendations (Including Randomness)
def get_diverse_recommendations(similarity_scores, df, top_n, diversity_factor=0.2):
    sorted_indices = similarity_scores.argsort()[::-1]  # Sort descending by similarity
    selected_indices = []

    # Select top results, but inject some randomness to increase diversity
    for i in range(top_n):
        if random.random() > diversity_factor:
            # Pick the next most similar item
            selected_indices.append(sorted_indices[i])
        else:
            # Inject diversity by selecting a random perfume from the top 10
            random_idx = random.choice(sorted_indices[:10])
            selected_indices.append(random_idx)

    return selected_indices


def recommendFragrance(user_input):
    expanded_user_input = expand_query_with_synonyms(user_input)
    
    # Load the dataset
    data = loadDataset('./Perfume_Dataset_Personal_Project.csv')

    # Create weighted features for similarity comparison
    combined_features = create_weighted_features(data)

    # Vectorization
    tfidf = TfidfVectorizer(stop_words='english')
    tfidf_matrix = tfidf.fit_transform(combined_features)

    # Transform User Input and Calculate Similarity
    user_tfidf = tfidf.transform([expanded_user_input])
    cosine_similarities = cosine_similarity(user_tfidf, tfidf_matrix).flatten()

    n = 5
    
    # Get top recommendations
    top_indices = get_diverse_recommendations(cosine_similarities, data, n)

    # Prepare list of dictionaries to return
    perfume_list = []

    for i in top_indices:
        brand = str(data.iloc[i]['Brand'])
        name = str(data.iloc[i]['Name'])
        notes = str(data.iloc[i]['All Notes'])
        description = str(data.iloc[i]['Description']).replace("\n", "").replace("Description","").replace("description","")
        url_image = str(data.iloc[i]['Image'])  
        
        # Append a dictionary with all required fields
        perfume_list.append({
            "Brand": brand,
            "Name": name,
            "Notes": notes,
            "Description": description,
            "See Image": url_image
        })
    
    # Check if the number of recommendations is less than 5, increase the number if necessary
    while len(perfume_list) < 5:
        n += 1
        top_indices = get_diverse_recommendations(cosine_similarities, data, n)
        for i in top_indices:
            brand = data.iloc[i]['Brand']
            name = data.iloc[i]['Name']
            notes = data.iloc[i]['All Notes']
            description = data.iloc[i]['Description']
            url_image = data.iloc[i]['Image']
            
            # Ensure duplicates are not added
            if not any(perfume['Name'] == name for perfume in perfume_list):
                perfume_list.append({
                    "Brand": brand,
                    "Name": name,
                    "Notes": notes,
                    "Description": description,
                    "See Image": url_image
                })
    
    return perfume_list
         
        
